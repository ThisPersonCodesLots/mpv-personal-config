<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VapourSynth4.h &mdash; VapourSynth R65 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=aa146b6a"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="VSHelper4.h" href="vshelper4.h.html" />
    <link rel="prev" title="VapourSynth C API Reference" href="../apireference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            VapourSynth
          </a>
              <div class="version">
                R65
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pythonreference.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../functions.html">Function Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications and Libraries</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../apireference.html">VapourSynth C API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../apireference.html#public-headers">Public Headers</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">VapourSynth4.h</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#table-of-contents">Table of contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structs">Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-plugins">Writing plugins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="vshelper4.h.html">VSHelper4.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="vsscript4.h.html">VSScript4.h</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../apireference.html#common-pitfalls">Common Pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../apireference.html#reserved-frame-properties">Reserved Frame Properties</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">VapourSynth</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../apireference.html">VapourSynth C API Reference</a></li>
      <li class="breadcrumb-item active">VapourSynth4.h</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/vapoursynth4.h.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vapoursynth4-h">
<h1>VapourSynth4.h<a class="headerlink" href="#vapoursynth4-h" title="Link to this heading"></a></h1>
<section id="table-of-contents">
<h2>Table of contents<a class="headerlink" href="#table-of-contents" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="#introduction">Introduction</a></p>
<dl>
<dt><a class="reference internal" href="#macros">Macros</a></dt><dd><p><a class="reference internal" href="#vs-cc">VS_CC</a></p>
<p><a class="reference internal" href="#vs-external-api">VS_EXTERNAL_API</a></p>
<p><a class="reference internal" href="#vapoursynth-api-major">VAPOURSYNTH_API_MAJOR</a></p>
<p><a class="reference internal" href="#vapoursynth-api-minor">VAPOURSYNTH_API_MINOR</a></p>
<p><a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a></p>
<p><a class="reference internal" href="#vs-audio-frame-samples">VS_AUDIO_FRAME_SAMPLES</a></p>
<p><a class="reference internal" href="#vs-make-version">VS_MAKE_VERSION</a></p>
</dd>
<dt><a class="reference internal" href="#enums">Enums</a></dt><dd><p><a class="reference internal" href="#vscolorfamily">VSColorFamily</a></p>
<p><a class="reference internal" href="#vssampletype">VSSampleType</a></p>
<p><a class="reference internal" href="#vspresetvideoformat">VSPresetVideoFormat</a></p>
<p><a class="reference internal" href="#vsfiltermode">VSFilterMode</a></p>
<p><a class="reference internal" href="#vsmediatype">VSMediaType</a></p>
<p><a class="reference internal" href="#vsaudiochannels">VSAudioChannels</a></p>
<p><a class="reference internal" href="#vspropertytype">VSPropertyType</a></p>
<p><a class="reference internal" href="#vsmappropertyerror">VSMapPropertyError</a></p>
<p><a class="reference internal" href="#vsmapappendmode">VSMapAppendMode</a></p>
<p><a class="reference internal" href="#vsactivationreason">VSActivationReason</a></p>
<p><a class="reference internal" href="#vsmessagetype">VSMessageType</a></p>
<p><a class="reference internal" href="#vscorecreationflags">VSCoreCreationFlags</a></p>
<p><a class="reference internal" href="#vspluginconfigflags">VSPluginConfigFlags</a></p>
<p><a class="reference internal" href="#vsdatatypehint">VSDataTypeHint</a></p>
<p><a class="reference internal" href="#vsrequestpattern">VSRequestPattern</a></p>
<p><a class="reference internal" href="#vscachemode">VSCacheMode</a></p>
</dd>
<dt><a class="reference internal" href="#structs">Structs</a></dt><dd><p><a class="reference internal" href="#vsframe">VSFrame</a></p>
<p><a class="reference internal" href="#vsnode">VSNode</a></p>
<p><a class="reference internal" href="#vscore">VSCore</a></p>
<p><a class="reference internal" href="#vsplugin">VSPlugin</a></p>
<p><a class="reference internal" href="#vspluginfunction">VSPluginFunction</a></p>
<p><a class="reference internal" href="#vsfunction">VSFunction</a></p>
<p><a class="reference internal" href="#vsmap">VSMap</a></p>
<p><a class="reference internal" href="#vsloghandle">VSLogHandle</a></p>
<p><a class="reference internal" href="#vsframecontext">VSFrameContext</a></p>
<p><a class="reference internal" href="#vsvideoformat">VSVideoFormat</a></p>
<p><a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a></p>
<p><a class="reference internal" href="#vsaudioformat">VSAudioFormat</a></p>
<p><a class="reference internal" href="#vsaudioinfo">VSAudioInfo</a></p>
<p><a class="reference internal" href="#vscoreinfo">VSCoreInfo</a></p>
<p><a class="reference internal" href="#vsfilterdependency">VSFilterDependency</a></p>
<p><a class="reference internal" href="#vspluginapi">VSPLUGINAPI</a></p>
<p><a class="reference internal" href="#vsapi">VSAPI</a></p>
<blockquote>
<div><ul>
<li><p>Functions that deal with the core:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createcore">createCore</a></p></li>
<li><p><a class="reference internal" href="#freecore">freeCore</a></p></li>
<li><p><a class="reference internal" href="#setmaxcachesize">setMaxCacheSize</a></p></li>
<li><p><a class="reference internal" href="#setthreadcount">setThreadCount</a></p></li>
<li><p><a class="reference internal" href="#getcoreinfo">getCoreInfo</a></p></li>
<li><p><a class="reference internal" href="#getapiversion">getAPIVersion</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with logging</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#addloghandler">addLogHandler</a></p></li>
<li><p><a class="reference internal" href="#removeloghandler">removeLogHandler</a></p></li>
<li><p><a class="reference internal" href="#logmessage">logMessage</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with frames:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#newvideoframe">newVideoFrame</a></p></li>
<li><p><a class="reference internal" href="#newvideoframe2">newVideoFrame2</a></p></li>
<li><p><a class="reference internal" href="#newaudioframe">newAudioFrame</a></p></li>
<li><p><a class="reference internal" href="#newaudioframe2">newAudioFrame2</a></p></li>
<li><p><a class="reference internal" href="#freeframe">freeFrame</a></p></li>
<li><p><a class="reference internal" href="#addframeref">addFrameRef</a></p></li>
<li><p><a class="reference internal" href="#copyframe">copyFrame</a></p></li>
<li><p><a class="reference internal" href="#getframepropertiesro">getFramePropertiesRO</a></p></li>
<li><p><a class="reference internal" href="#getframepropertiesrw">getFramePropertiesRW</a></p></li>
<li><p><a class="reference internal" href="#getstride">getStride</a></p></li>
<li><p><a class="reference internal" href="#getreadptr">getReadPtr</a></p></li>
<li><p><a class="reference internal" href="#getwriteptr">getWritePtr</a></p></li>
<li><p><a class="reference internal" href="#getvideoframeformat">getVideoFrameFormat</a></p></li>
<li><p><a class="reference internal" href="#getaudioframeformat">getAudioFrameFormat</a></p></li>
<li><p><a class="reference internal" href="#getframetype">getFrameType</a></p></li>
<li><p><a class="reference internal" href="#getframewidth">getFrameWidth</a></p></li>
<li><p><a class="reference internal" href="#getframeheight">getFrameHeight</a></p></li>
<li><p><a class="reference internal" href="#getframelength">getFrameLength</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with filters and nodes:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createvideofilter">createVideoFilter</a></p></li>
<li><p><a class="reference internal" href="#createvideofilter2">createVideoFilter2</a></p></li>
<li><p><a class="reference internal" href="#createaudiofilter">createAudioFilter</a></p></li>
<li><p><a class="reference internal" href="#createaudiofilter2">createAudioFilter2</a></p></li>
<li><p><a class="reference internal" href="#setlinearfilter">setLinearFilter</a></p></li>
<li><p><a class="reference internal" href="#setcachemode">setCacheMode</a></p></li>
<li><p><a class="reference internal" href="#setcacheoptions">setCacheOptions</a></p></li>
<li><p><a class="reference internal" href="#freenode">freeNode</a></p></li>
<li><p><a class="reference internal" href="#addnoderef">addNodeRef</a></p></li>
<li><p><a class="reference internal" href="#getnodetype">getNodeType</a></p></li>
<li><p><a class="reference internal" href="#getvideoinfo">getVideoInfo</a></p></li>
<li><p><a class="reference internal" href="#getaudioinfo">getAudioInfo</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with formats:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#getvideoformatname">getVideoFormatName</a></p></li>
<li><p><a class="reference internal" href="#getaudioformatname">getAudioFormatName</a></p></li>
<li><p><a class="reference internal" href="#queryvideoformat">queryVideoFormat</a></p></li>
<li><p><a class="reference internal" href="#queryaudioformat">queryAudioFormat</a></p></li>
<li><p><a class="reference internal" href="#queryvideoformatid">queryVideoFormatID</a></p></li>
<li><p><a class="reference internal" href="#getvideoformatbyid">getVideoFormatByID</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with maps:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createmap">createMap</a></p></li>
<li><p><a class="reference internal" href="#freemap">freeMap</a></p></li>
<li><p><a class="reference internal" href="#clearmap">clearMap</a></p></li>
<li><p><a class="reference internal" href="#mapgeterror">mapGetError</a></p></li>
<li><p><a class="reference internal" href="#mapseterror">mapSetError</a></p></li>
<li><p><a class="reference internal" href="#mapnumkeys">mapNumKeys</a></p></li>
<li><p><a class="reference internal" href="#mapgetkey">mapGetKey</a></p></li>
<li><p><a class="reference internal" href="#mapdeletekey">mapDeleteKey</a></p></li>
<li><p><a class="reference internal" href="#mapnumelements">mapNumElements</a></p></li>
<li><p><a class="reference internal" href="#mapgettype">mapGetType</a></p></li>
<li><p><a class="reference internal" href="#mapsetempty">mapSetEmpty</a></p></li>
<li><p><a class="reference internal" href="#mapgetint">mapGetInt</a></p></li>
<li><p><a class="reference internal" href="#mapgetintsaturated">mapGetIntSaturated</a></p></li>
<li><p><a class="reference internal" href="#mapgetintarray">mapGetIntArray</a></p></li>
<li><p><a class="reference internal" href="#mapsetint">mapSetInt</a></p></li>
<li><p><a class="reference internal" href="#mapsetintarray">mapSetIntArray</a></p></li>
<li><p><a class="reference internal" href="#mapgetfloat">mapGetFloat</a></p></li>
<li><p><a class="reference internal" href="#mapgetfloatsaturated">mapGetFloatSaturated</a></p></li>
<li><p><a class="reference internal" href="#mapgetfloatarray">mapGetFloatArray</a></p></li>
<li><p><a class="reference internal" href="#mapsetfloat">mapSetFloat</a></p></li>
<li><p><a class="reference internal" href="#mapsetfloatarray">mapSetFloatArray</a></p></li>
<li><p><a class="reference internal" href="#mapgetdata">mapGetData</a></p></li>
<li><p><a class="reference internal" href="#mapgetdatasize">mapGetDataSize</a></p></li>
<li><p><a class="reference internal" href="#mapgetdatatypehint">mapGetDataTypeHint</a></p></li>
<li><p><a class="reference internal" href="#mapsetdata">mapSetData</a></p></li>
<li><p><a class="reference internal" href="#mapgetnode">mapGetNode</a></p></li>
<li><p><a class="reference internal" href="#mapsetnode">mapSetNode</a></p></li>
<li><p><a class="reference internal" href="#mapconsumenode">mapConsumeNode</a></p></li>
<li><p><a class="reference internal" href="#mapgetframe">mapGetFrame</a></p></li>
<li><p><a class="reference internal" href="#mapsetframe">mapSetFrame</a></p></li>
<li><p><a class="reference internal" href="#mapconsumeframe">mapConsumeFrame</a></p></li>
<li><p><a class="reference internal" href="#mapgetfunction">mapGetFunction</a></p></li>
<li><p><a class="reference internal" href="#mapsetfunction">mapSetFunction</a></p></li>
<li><p><a class="reference internal" href="#mapconsumefunction">mapConsumeFunction</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with plugins and plugin functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#registerfunction">registerFunction</a></p></li>
<li><p><a class="reference internal" href="#getpluginbyid">getPluginByID</a></p></li>
<li><p><a class="reference internal" href="#getpluginbynamespace">getPluginByNamespace</a></p></li>
<li><p><a class="reference internal" href="#getnextplugin">getNextPlugin</a></p></li>
<li><p><a class="reference internal" href="#getpluginname">getPluginName</a></p></li>
<li><p><a class="reference internal" href="#getpluginid">getPluginID</a></p></li>
<li><p><a class="reference internal" href="#getpluginnamespace">getPluginNamespace</a></p></li>
<li><p><a class="reference internal" href="#getnextpluginfunction">getNextPluginFunction</a></p></li>
<li><p><a class="reference internal" href="#getpluginfunctionbyname">getPluginFunctionByName</a></p></li>
<li><p><a class="reference internal" href="#getpluginfunctionname">getPluginFunctionName</a></p></li>
<li><p><a class="reference internal" href="#getpluginfunctionarguments">getPluginFunctionArguments</a></p></li>
<li><p><a class="reference internal" href="#getpluginfunctionreturntype">getPluginFunctionReturnType</a></p></li>
<li><p><a class="reference internal" href="#getpluginpath">getPluginPath</a></p></li>
<li><p><a class="reference internal" href="#getpluginversion">getPluginVersion</a></p></li>
<li><p><a class="reference internal" href="#invoke">invoke</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with wrapped external functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createfunction">createFunction</a></p></li>
<li><p><a class="reference internal" href="#freefunction">freeFunction</a></p></li>
<li><p><a class="reference internal" href="#addfunctionref">addFunctionRef</a></p></li>
<li><p><a class="reference internal" href="#callfunction">callFunction</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that are used to fetch frames and inside filters:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#getframe">getFrame</a></p></li>
<li><p><a class="reference internal" href="#getframeasync">getFrameAsync</a></p></li>
<li><p><a class="reference internal" href="#getframefilter">getFrameFilter</a></p></li>
<li><p><a class="reference internal" href="#requestframefilter">requestFrameFilter</a></p></li>
<li><p><a class="reference internal" href="#releaseframeearly">releaseFrameEarly</a></p></li>
<li><p><a class="reference internal" href="#cacheframe">cacheFrame</a></p></li>
<li><p><a class="reference internal" href="#setfiltererror">setFilterError</a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
<dt><a class="reference internal" href="#functions">Functions</a></dt><dd><p><a class="reference internal" href="#getvapoursynthapi">getVapourSynthAPI</a></p>
</dd>
<dt><a class="reference internal" href="#writing-plugins">Writing plugins</a></dt><dd><p><a class="reference internal" href="#vsinitplugin">VSInitPlugin</a></p>
<p><a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a></p>
<p><a class="reference internal" href="#vsfilterfree">VSFilterFree</a></p>
</dd>
</dl>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>This is VapourSynth’s main header file. Plugins and applications that use
the library must include it.</p>
<p>VapourSynth’s public API is all C.</p>
</section>
<section id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Link to this heading"></a></h2>
<p>VapourSynth4.h defines some preprocessor macros that make the programmer’s life
easier. The relevant ones are described below.</p>
<section id="vs-cc">
<h3>VS_CC<a class="headerlink" href="#vs-cc" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">VS_CC</span></code> macro expands to the calling convention used by VapourSynth.
All functions meant to be called by VapourSynth must use this macro (a
filter’s “init”, “getframe”, “free” functions, etc).</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VS_CC</span><span class="w"> </span><span class="nf">fooInit</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="vs-external-api">
<h3>VS_EXTERNAL_API<a class="headerlink" href="#vs-external-api" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">VS_EXTERNAL_API</span></code> macro expands to the platform-specific magic required
for functions exported by shared libraries. It also takes care of adding
<code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> when needed, and <code class="docutils literal notranslate"><span class="pre">VS_CC</span></code>.</p>
<p>This macro must be used for a plugin’s entry point, like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">VS_EXTERNAL_API</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">VapourSynthPluginInit2</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="vapoursynth-api-major">
<h3>VAPOURSYNTH_API_MAJOR<a class="headerlink" href="#vapoursynth-api-major" title="Link to this heading"></a></h3>
<p>Major API version.</p>
</section>
<section id="vapoursynth-api-minor">
<h3>VAPOURSYNTH_API_MINOR<a class="headerlink" href="#vapoursynth-api-minor" title="Link to this heading"></a></h3>
<p>Minor API version. It is bumped when new functions are added to <a class="reference internal" href="#vsapi">VSAPI</a> or core behavior is noticeably changed.</p>
</section>
<section id="vapoursynth-api-version">
<h3>VAPOURSYNTH_API_VERSION<a class="headerlink" href="#vapoursynth-api-version" title="Link to this heading"></a></h3>
<p>API version. The high 16 bits are <a class="reference internal" href="#vapoursynth-api-major">VAPOURSYNTH_API_MAJOR</a>, the low 16
bits are <a class="reference internal" href="#vapoursynth-api-minor">VAPOURSYNTH_API_MINOR</a>.</p>
</section>
<section id="vs-audio-frame-samples">
<h3>VS_AUDIO_FRAME_SAMPLES<a class="headerlink" href="#vs-audio-frame-samples" title="Link to this heading"></a></h3>
<p>The number of audio samples in an audio frame. It is a static number to make it possible to calculate which audio frames are needed to retrieve specific samples.</p>
</section>
<section id="vs-make-version">
<h3>VS_MAKE_VERSION<a class="headerlink" href="#vs-make-version" title="Link to this heading"></a></h3>
<p>Used to create version numbers. The first argument is the major version and second is the minor.</p>
</section>
</section>
<section id="enums">
<h2>Enums<a class="headerlink" href="#enums" title="Link to this heading"></a></h2>
<section id="enum-vscolorfamily">
<span id="vscolorfamily"></span><h3>enum VSColorFamily<a class="headerlink" href="#enum-vscolorfamily" title="Link to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>cfUndefined</p></li>
<li><p>cfGray</p></li>
<li><p>cfRGB</p></li>
<li><p>cfYUV</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vssampletype">
<span id="vssampletype"></span><h3>enum VSSampleType<a class="headerlink" href="#enum-vssampletype" title="Link to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>stInteger</p></li>
<li><p>stFloat</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vspresetvideoformat">
<span id="vspresetvideoformat"></span><h3>enum VSPresetVideoFormat<a class="headerlink" href="#enum-vspresetvideoformat" title="Link to this heading"></a></h3>
<blockquote>
<div><p>The presets suffixed with H and S have floating point sample type.
The H and S suffixes stand for half precision and single precision,
respectively. All formats are planar. See the header for all currently
defined video format presets.</p>
<ul class="simple">
<li><p>pf*</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsfiltermode">
<span id="vsfiltermode"></span><h3>enum VSFilterMode<a class="headerlink" href="#enum-vsfiltermode" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Controls how a filter will be multithreaded, if at all.</p>
<ul>
<li><p>fmParallel</p>
<p>Completely parallel execution.
Multiple threads will call a filter’s “getframe” function, to fetch several
frames in parallel.</p>
</li>
<li><p>fmParallelRequests</p>
<p>For filters that are serial in nature but can request in advance one or
more frames they need.
A filter’s “getframe” function will be called from multiple threads at a
time with activation reason arInitial, but only one thread will call it
with activation reason arAllFramesReady at a time.</p>
</li>
<li><p>fmUnordered</p>
<p>Only one thread can call the filter’s “getframe” function at a time.
Useful for filters that modify or examine their internal state to
determine which frames to request.</p>
<p>While the “getframe” function will only run in one thread at a
time, the calls can happen in any order. For example, it can be
called with reason arInitial for frame 0, then again with reason
arInitial for frame 1, then with reason arAllFramesReady for
frame 0.</p>
</li>
<li><p>fmFrameState</p>
<p>For compatibility with other filtering architectures. DO NOT USE IN NEW FILTERS.
The filter’s “getframe” function only ever gets called from one thread at a
time. Unlike fmUnordered, only one frame is processed at a time.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsmediatype">
<span id="vsmediatype"></span><h3>enum VSMediaType<a class="headerlink" href="#enum-vsmediatype" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Used to indicate the type of a <cite>VSFrame</cite> or <cite>VSNode</cite> object.</p>
<ul class="simple">
<li><p>mtVideo</p></li>
<li><p>mtAudio</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsaudiochannels">
<span id="vsaudiochannels"></span><h3>enum VSAudioChannels<a class="headerlink" href="#enum-vsaudiochannels" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Audio channel positions as an enum. Mirrors the FFmpeg audio channel constants in older api versions. See the header for all available values.</p>
<ul class="simple">
<li><p>ac*</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vspropertytype">
<span id="vspropertytype"></span><h3>enum VSPropertyType<a class="headerlink" href="#enum-vspropertytype" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Types of properties that can be stored in a VSMap.</p>
<ul class="simple">
<li><p>ptUnset</p></li>
<li><p>ptInt</p></li>
<li><p>ptFloat</p></li>
<li><p>ptData</p></li>
<li><p>ptFunction</p></li>
<li><p>ptVideoNode</p></li>
<li><p>ptAudioNode</p></li>
<li><p>ptVideoFrame</p></li>
<li><p>ptAudioFrame</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsmappropertyerror">
<span id="vsmappropertyerror"></span><h3>enum VSMapPropertyError<a class="headerlink" href="#enum-vsmappropertyerror" title="Link to this heading"></a></h3>
<blockquote>
<div><p>When a mapGet* function fails, it returns one of these in the <em>err</em>
parameter.</p>
<p>All errors are non-zero.</p>
<ul>
<li><p>peSuccess</p></li>
<li><p>peUnset</p>
<p>The requested key was not found in the map.</p>
</li>
<li><p>peType</p>
<p>The wrong function was used to retrieve the property. E.g.
<a class="reference internal" href="#mapgetint">mapGetInt</a>() was used on a property of type ptFloat.</p>
</li>
<li><p>peIndex</p>
<p>The requested index was out of bounds.</p>
</li>
<li><p>peError</p>
<p>The map has the error state set.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsmapappendmode">
<span id="vsmapappendmode"></span><h3>enum VSMapAppendMode<a class="headerlink" href="#enum-vsmapappendmode" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Controls the behaviour of <a class="reference internal" href="#mapsetint">mapSetInt</a>() and friends.</p>
<ul>
<li><p>maReplace</p>
<p>All existing values associated with the key will be replaced with
the new value.</p>
</li>
<li><p>maAppend</p>
<p>The new value will be appended to the list of existing values
associated with the key.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsactivationreason">
<span id="vsactivationreason"></span><h3>enum VSActivationReason<a class="headerlink" href="#enum-vsactivationreason" title="Link to this heading"></a></h3>
<blockquote>
<div><p>See <a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a>.</p>
<ul class="simple">
<li><p>arInitial</p></li>
<li><p>arAllFramesReady</p></li>
<li><p>arError</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsmessagetype">
<span id="vsmessagetype"></span><h3>enum VSMessageType<a class="headerlink" href="#enum-vsmessagetype" title="Link to this heading"></a></h3>
<blockquote>
<div><p>See <a class="reference internal" href="#addloghandler">addLogHandler</a>().</p>
<ul class="simple">
<li><p>mtDebug</p></li>
<li><p>mtInformation</p></li>
<li><p>mtWarning</p></li>
<li><p>mtCritical</p></li>
<li><p>mtFatal</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vscorecreationflags">
<span id="vscorecreationflags"></span><h3>enum VSCoreCreationFlags<a class="headerlink" href="#enum-vscorecreationflags" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Options when creating a core.</p>
<ul>
<li><p>ccfEnableGraphInspection</p>
<blockquote>
<div><p>Required to use the graph inspection api functions. Increases memory usage due to the extra information stored.</p>
</div></blockquote>
</li>
<li><p>ccfDisableAutoLoading</p>
<blockquote>
<div><p>Don’t autoload any user plugins. Core plugins are always loaded.</p>
</div></blockquote>
</li>
<li><p>ccfDisableLibraryUnloading</p>
<blockquote>
<div><p>Don’t unload plugin libraries when the core is destroyed. Due to a small amount of memory leaking every load
and unload (windows feature, not my fault) of a library this may help in applications with extreme amount of script reloading.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vspluginconfigflags">
<span id="vspluginconfigflags"></span><h3>enum VSPluginConfigFlags<a class="headerlink" href="#enum-vspluginconfigflags" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Options when loading a plugin.</p>
<ul>
<li><p>pcModifiable</p>
<blockquote>
<div><p>Allow functions to be added to the plugin object after the plugin loading phase. Mostly useful for
Avisynth compatibility and other foreign plugin loaders.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsdatatypehint">
<span id="vsdatatypehint"></span><h3>enum VSDataTypeHint<a class="headerlink" href="#enum-vsdatatypehint" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Since the data type can contain both pure binary data and printable strings the type also contains a hint
for whether or not it is human readable. Generally the unknown type should be very rare and is almost only
created as an artifact of API3 compatibility.</p>
<ul class="simple">
<li><p>dtUnknown</p></li>
<li><p>dtBinary</p></li>
<li><p>dtUtf8</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsrequestpattern">
<span id="vsrequestpattern"></span><h3>enum VSRequestPattern<a class="headerlink" href="#enum-vsrequestpattern" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Describes the upstream frame request pattern of a filter.</p>
<ul>
<li><p>rpGeneral</p>
<blockquote>
<div><p>Anything goes. Note that filters that may be requesting beyond the end of a VSNode length in frames (repeating the last frame) should use <em>rpGeneral</em> and not any of the other modes.</p>
</div></blockquote>
</li>
<li><p>rpNoFrameReuse</p>
<p>Will only request an input frame at most once if all output frames are requested exactly one time. This includes filters such as Trim, Reverse, SelectEvery.</p>
</li>
<li><p>rpStrictSpatial</p>
<p>Only requests frame N to output frame N. The main difference to <em>rpNoFrameReuse</em> is that the requested frame is always fixed and known ahead of time. Filter examples Lut, Expr (conditionally, see <em>rpGeneral</em> note) and similar.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vscachemode">
<span id="vscachemode"></span><h3>enum VSCacheMode<a class="headerlink" href="#enum-vscachemode" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Describes how the output of a node is cached.</p>
<ul>
<li><p>cmAuto</p>
<blockquote>
<div><p>Cache is enabled or disabled based on the reported request patterns and number of consumers.</p>
</div></blockquote>
</li>
<li><p>cmForceDisable</p>
<blockquote>
<div><p>Never cache anything.</p>
</div></blockquote>
</li>
<li><p>cmForceEnable</p>
<blockquote>
<div><ul class="simple">
<li><p>Always use the cache.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
</section>
<section id="structs">
<h2>Structs<a class="headerlink" href="#structs" title="Link to this heading"></a></h2>
<p>Most structs are opaque and their contents can only be accessed using functions in the API.</p>
<section id="struct-vsframe">
<span id="vsframe"></span><h3>struct VSFrame<a class="headerlink" href="#struct-vsframe" title="Link to this heading"></a></h3>
<blockquote>
<div><p>A frame that can hold audio or video data.</p>
<p>Each row of pixels in a frame is guaranteed to have an alignment of at least 32
bytes. Two frames with the same width and bytes per sample are guaranteed to have the same stride.</p>
<p>Audio data is also guaranteed to be at least 32 byte aligned.</p>
<p>Any data can be attached to a frame, using a <a class="reference internal" href="#vsmap">VSMap</a>.</p>
</div></blockquote>
</section>
<section id="struct-vsnode">
<span id="vsnode"></span><h3>struct VSNode<a class="headerlink" href="#struct-vsnode" title="Link to this heading"></a></h3>
<blockquote>
<div><p>A reference to a node in the constructed filter graph. Its primary use
is as an argument to other filter or to request frames from.</p>
</div></blockquote>
</section>
<section id="struct-vscore">
<span id="vscore"></span><h3>struct VSCore<a class="headerlink" href="#struct-vscore" title="Link to this heading"></a></h3>
<blockquote>
<div><p>The core represents one instance of VapourSynth. Every core individually
loads plugins and keeps track of memory.</p>
</div></blockquote>
</section>
<section id="struct-vsplugin">
<span id="vsplugin"></span><h3>struct VSPlugin<a class="headerlink" href="#struct-vsplugin" title="Link to this heading"></a></h3>
<blockquote>
<div><p>A VapourSynth plugin. There are a few of these built into the core,
and therefore available at all times: the basic filters (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.std</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">std</span></code>), the resizers (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.resize</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">resize</span></code>), and the Avisynth
compatibility module, if running in Windows (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.avisynth</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">avs</span></code>).</p>
<p>The Function Reference describes how to load VapourSynth and Avisynth
plugins.</p>
<p>A VSPlugin instance is constructed by the core when loading a plugin
(.so / .dylib / .dll), and the pointer is passed to the plugin’s
VapourSynthPluginInit2() function.</p>
<p>A VapourSynth plugin can export any number of filters.</p>
<p>Plugins have a few attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p>An identifier, which must be unique among all VapourSynth plugins in
existence, because this is what the core uses to make sure a plugin
only gets loaded once.</p></li>
<li><p>A namespace, also unique. The filters exported by a plugin end up in
the plugin’s namespace.</p></li>
<li><p>A full name, which is used by the core in a few error messages.</p></li>
<li><p>The version of the plugin.</p></li>
<li><p>The VapourSynth API version the plugin requires.</p></li>
<li><p>A file name.</p></li>
</ul>
</div></blockquote>
<p>Things you can do with a VSPlugin:</p>
<blockquote>
<div><ul class="simple">
<li><p>Enumerate all the filters it exports, using <a class="reference internal" href="#getnextpluginfunction">getNextPluginFunction</a>().</p></li>
<li><p>Invoke one of its filters, using <a class="reference internal" href="#invoke">invoke</a>().</p></li>
<li><p>Get its location in the file system, using <a class="reference internal" href="#getpluginpath">getPluginPath</a>().</p></li>
</ul>
</div></blockquote>
<p>All loaded plugins (including built-in) can be enumerated with
<a class="reference internal" href="#getnextplugin">getNextPlugin</a>().</p>
<p>Once loaded, a plugin only gets unloaded when the VapourSynth core is freed.</p>
</div></blockquote>
</section>
<section id="struct-vspluginfunction">
<span id="vspluginfunction"></span><h3>struct VSPluginFunction<a class="headerlink" href="#struct-vspluginfunction" title="Link to this heading"></a></h3>
<blockquote>
<div><p>A function belonging to a Vapoursynth plugin. This object primarily exists so
a plugin’s name, argument list and return type can be queried by editors.</p>
<p>One peculiarity is that plugin functions cannot be invoked using a <cite>VSPluginFunction</cite>
pointer but is instead done using <a class="reference internal" href="#invoke">invoke</a>() which takes a <cite>VSPlugin</cite> and
the function name as a string.</p>
</div></blockquote>
</section>
<section id="struct-vsfunction">
<span id="vsfunction"></span><h3>struct VSFunction<a class="headerlink" href="#struct-vsfunction" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Holds a reference to a function that may be called. This type primarily exists
so functions can be shared between the scripting layer and plugins in the core.</p>
</div></blockquote>
</section>
<section id="struct-vsmap">
<span id="vsmap"></span><h3>struct VSMap<a class="headerlink" href="#struct-vsmap" title="Link to this heading"></a></h3>
<blockquote>
<div><p>VSMap is a container that stores (key,value) pairs. The keys are strings
and the values can be (arrays of) integers, floating point numbers,
arrays of bytes, <a class="reference internal" href="#vsnode">VSNode</a>, <a class="reference internal" href="#vsframe">VSFrame</a>, or <a class="reference internal" href="#vsfunction">VSFunction</a>.</p>
<p>The pairs in a VSMap are sorted by key.</p>
<dl class="simple">
<dt>In VapourSynth, VSMaps have several uses:</dt><dd><ul class="simple">
<li><p>storing filters’ arguments and return values</p></li>
<li><p>storing user-defined functions’ arguments and return values</p></li>
<li><p>storing the properties attached to frames</p></li>
</ul>
</dd>
</dl>
<p>Only alphanumeric characters and the underscore may be used in keys.</p>
<p>Creating and destroying a map can be done with <a class="reference internal" href="#createmap">createMap</a>() and
<a class="reference internal" href="#freemap">freeMap</a>(), respectively.</p>
<p>A map’s contents can be retrieved and modified using a number of functions,
all prefixed with “map”.</p>
<p>A map’s contents can be erased with <a class="reference internal" href="#clearmap">clearMap</a>().</p>
</div></blockquote>
</section>
<section id="struct-vsloghandle">
<span id="vsloghandle"></span><h3>struct VSLogHandle<a class="headerlink" href="#struct-vsloghandle" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Opaque type representing a registered logger.</p>
</div></blockquote>
</section>
<section id="struct-vsframecontext">
<span id="vsframecontext"></span><h3>struct VSFrameContext<a class="headerlink" href="#struct-vsframecontext" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Opaque type representing the current frame request in a filter.</p>
</div></blockquote>
</section>
<section id="struct-vsvideoformat">
<span id="vsvideoformat"></span><h3>struct VSVideoFormat<a class="headerlink" href="#struct-vsvideoformat" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Describes the format of a clip.</p>
<p>Use <a class="reference internal" href="#queryvideoformat">queryVideoFormat</a>() to fill it in with proper error checking. Manually filling out the struct is allowed but discouraged
since illegal combinations of values will cause undefined behavior.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.colorFamily">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">colorFamily</span></span></span><a class="headerlink" href="#c.colorFamily" title="Link to this definition"></a><br /></dt>
<dd><p>See <a class="reference internal" href="#vscolorfamily">VSColorFamily</a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.sampleType">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sampleType</span></span></span><a class="headerlink" href="#c.sampleType" title="Link to this definition"></a><br /></dt>
<dd><p>See <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.bitsPerSample">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitsPerSample</span></span></span><a class="headerlink" href="#c.bitsPerSample" title="Link to this definition"></a><br /></dt>
<dd><p>Number of significant bits.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.bytesPerSample">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bytesPerSample</span></span></span><a class="headerlink" href="#c.bytesPerSample" title="Link to this definition"></a><br /></dt>
<dd><p>Number of bytes needed for a sample. This is always a power of 2 and the
smallest possible that can fit the number of bits used per sample.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.subSamplingW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subSamplingW</span></span></span><a class="headerlink" href="#c.subSamplingW" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.subSamplingH">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subSamplingH</span></span></span><a class="headerlink" href="#c.subSamplingH" title="Link to this definition"></a><br /></dt>
<dd><p>log2 subsampling factor, applied to second and third plane.
Convenient numbers that can be used like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">uv_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_width</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">subSamplingW</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numPlanes">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numPlanes</span></span></span><a class="headerlink" href="#c.numPlanes" title="Link to this definition"></a><br /></dt>
<dd><p>Number of planes.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsvideoinfo">
<span id="vsvideoinfo"></span><h3>struct VSVideoInfo<a class="headerlink" href="#struct-vsvideoinfo" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Contains information about a clip.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.format">
<span class="n"><span class="pre">VSVideoFormat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><a class="headerlink" href="#c.format" title="Link to this definition"></a><br /></dt>
<dd><p>Format of the clip. Will have <em>colorFamily</em> set to <em>cfUndefined</em> if the format can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.fpsNum">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fpsNum</span></span></span><a class="headerlink" href="#c.fpsNum" title="Link to this definition"></a><br /></dt>
<dd><p>Numerator part of the clip’s frame rate. It will be 0 if the frame
rate can vary. Should always be a reduced fraction.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.fpsDen">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fpsDen</span></span></span><a class="headerlink" href="#c.fpsDen" title="Link to this definition"></a><br /></dt>
<dd><p>Denominator part of the clip’s frame rate. It will be 0 if the frame
rate can vary. Should always be a reduced fraction.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.width">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">width</span></span></span><a class="headerlink" href="#c.width" title="Link to this definition"></a><br /></dt>
<dd><p>Width of the clip. Both width and height will be 0 if the clip’s dimensions can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.height">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">height</span></span></span><a class="headerlink" href="#c.height" title="Link to this definition"></a><br /></dt>
<dd><p>Height of the clip. Both width and height will be 0 if the clip’s dimensions can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numFrames">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numFrames</span></span></span><a class="headerlink" href="#c.numFrames" title="Link to this definition"></a><br /></dt>
<dd><p>Length of the clip.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsaudioformat">
<span id="vsaudioformat"></span><h3>struct VSAudioFormat<a class="headerlink" href="#struct-vsaudioformat" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Describes the format of a clip.</p>
<p>Use <a class="reference internal" href="#queryaudioformat">queryAudioFormat</a>() to fill it in with proper error checking. Manually filling out the struct is allowed but discouraged
since illegal combinations of values will cause undefined behavior.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sampleType</span></span></span><br /></dt>
<dd><p>See <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitsPerSample</span></span></span><br /></dt>
<dd><p>Number of significant bits.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bytesPerSample</span></span></span><br /></dt>
<dd><p>Number of bytes needed for a sample. This is always a power of 2 and the
smallest possible that can fit the number of bits used per sample.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numChannels">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numChannels</span></span></span><a class="headerlink" href="#c.numChannels" title="Link to this definition"></a><br /></dt>
<dd><p>Number of audio channels.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.channelLayout">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">channelLayout</span></span></span><a class="headerlink" href="#c.channelLayout" title="Link to this definition"></a><br /></dt>
<dd><p>A bitmask representing the channels present using the constants in 1 left shifted by the constants in <a class="reference internal" href="#vsaudiochannels">VSAudioChannels</a>.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsaudioinfo">
<span id="vsaudioinfo"></span><h3>struct VSAudioInfo<a class="headerlink" href="#struct-vsaudioinfo" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Contains information about a clip.</p>
<dl class="c member">
<dt class="sig sig-object c">
<span class="n"><span class="pre">VSAudioFormat</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><br /></dt>
<dd><p>Format of the clip. Unlike video the audio format can never change.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.sampleRate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sampleRate</span></span></span><a class="headerlink" href="#c.sampleRate" title="Link to this definition"></a><br /></dt>
<dd><p>Sample rate.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numSamples">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numSamples</span></span></span><a class="headerlink" href="#c.numSamples" title="Link to this definition"></a><br /></dt>
<dd><p>Length of the clip in audio samples.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numFrames</span></span></span><br /></dt>
<dd><p>Length of the clip in audio frames.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vscoreinfo">
<span id="vscoreinfo"></span><h3>struct VSCoreInfo<a class="headerlink" href="#struct-vscoreinfo" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Contains information about a <a class="reference internal" href="#vscore">VSCore</a> instance.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.versionString">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">versionString</span></span></span><a class="headerlink" href="#c.versionString" title="Link to this definition"></a><br /></dt>
<dd><p>Printable string containing the name of the library, copyright notice,
core and API versions.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.core">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">core</span></span></span><a class="headerlink" href="#c.core" title="Link to this definition"></a><br /></dt>
<dd><p>Version of the core.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.api">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">api</span></span></span><a class="headerlink" href="#c.api" title="Link to this definition"></a><br /></dt>
<dd><p>Version of the API.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numThreads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numThreads</span></span></span><a class="headerlink" href="#c.numThreads" title="Link to this definition"></a><br /></dt>
<dd><p>Number of worker threads.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.maxFramebufferSize">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">maxFramebufferSize</span></span></span><a class="headerlink" href="#c.maxFramebufferSize" title="Link to this definition"></a><br /></dt>
<dd><p>The framebuffer cache will be allowed to grow up to this size (bytes) before memory is aggressively reclaimed.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.usedFramebufferSize">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">usedFramebufferSize</span></span></span><a class="headerlink" href="#c.usedFramebufferSize" title="Link to this definition"></a><br /></dt>
<dd><p>Current size of the framebuffer cache, in bytes.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsfilterdependency">
<span id="vsfilterdependency"></span><h3>struct VSFilterDependency<a class="headerlink" href="#struct-vsfilterdependency" title="Link to this heading"></a></h3>
<blockquote>
<div><p>Contains information about a <a class="reference internal" href="#vscore">VSCore</a> instance.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.source">
<span class="n"><span class="pre">VSNode</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">source</span></span></span><a class="headerlink" href="#c.source" title="Link to this definition"></a><br /></dt>
<dd><p>The node frames are requested from.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.requestPattern">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">requestPattern</span></span></span><a class="headerlink" href="#c.requestPattern" title="Link to this definition"></a><br /></dt>
<dd><p>A value from <a class="reference internal" href="#vsrequestpattern">VSRequestPattern</a>.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vspluginapi">
<span id="vspluginapi"></span><h3>struct VSPLUGINAPI<a class="headerlink" href="#struct-vspluginapi" title="Link to this heading"></a></h3>
<blockquote>
<div><p>This struct is used to access VapourSynth’s API when a plugin is initially loaded.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>int getAPIVersion()</p>
<blockquote>
<div><p>See <a class="reference internal" href="#getapiversion">getAPIVersion</a>() in the struct <a class="reference internal" href="#vsapi">VSAPI</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="configplugin">int configPlugin(const char *identifier, const char *pluginNamespace, const char *name, int pluginVersion, int apiVersion, int flags, VSPlugin *plugin)</p>
<blockquote>
<div><p>Used to provide information about a plugin when loaded. Must be called exactly once from the <em>VapourSynthPluginInit2</em> entry point.
It is recommended to use the <a class="reference internal" href="#vs-make-version">VS_MAKE_VERSION</a> macro when providing the <em>pluginVersion</em>. If you don’t know the specific <em>apiVersion</em> you actually require simply
pass <a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a> to match the header version you’re compiling against. The <em>flags</em> consist of values from <a class="reference internal" href="#vspluginconfigflags">VSPluginConfigFlags</a> ORed together
but should for most plugins typically be 0.</p>
<p>Returns non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>int registerFunction(const char *name, const char *args, const char *returnType, VSPublicFunction argsFunc, void *functionData, VSPlugin *plugin)</p>
<blockquote>
<div><p>See <a class="reference internal" href="#registerfunction">registerFunction</a>() in the struct <a class="reference internal" href="#vsapi">VSAPI</a>.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="struct-vsapi">
<span id="vsapi"></span><h3>struct VSAPI<a class="headerlink" href="#struct-vsapi" title="Link to this heading"></a></h3>
<blockquote>
<div><p>This giant struct is the way to access VapourSynth’s public API.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createcore"><a class="reference internal" href="#vscore">VSCore</a> *createCore(int flags)</p>
<blockquote>
<div><p>Creates the VapourSynth processing core and returns a pointer to it. It is
possible to create multiple cores but in most cases it shouldn’t be needed.</p>
<dl class="simple">
<dt><em>flags</em></dt><dd><p><cite>VSCoreCreationFlags</cite> ORed together if desired. Pass 0 for sane defaults
that should suit most uses.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freecore">void freeCore(<a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Frees a core. Should only be done after all frame requests have completed
and all objects belonging to the core have been released.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setmaxcachesize">int64_t setMaxCacheSize(int64_t bytes, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Sets the maximum size of the framebuffer cache. Returns the new maximum
size.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setthreadcount">int setThreadCount(int threads, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Sets the number of threads used for processing. Pass 0 to automatically detect.
Returns the number of threads that will be used for processing.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getcoreinfo">void getCoreInfo(<a class="reference internal" href="#vscore">VSCore</a> *core, <a class="reference internal" href="#vscoreinfo">VSCoreInfo</a> *info)</p>
<blockquote>
<div><p>Returns information about the VapourSynth core.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getapiversion">int getAPIVersion()</p>
<blockquote>
<div><p>Returns the highest <a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a> the library support.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="logmessage">void logMessage(int msgType, const char *msg, VSCore *core)</p>
<blockquote>
<div><p>Send a message through VapourSynth’s logging framework. See
<a class="reference internal" href="#addloghandler">addLogHandler</a>.</p>
<dl>
<dt><em>msgType</em></dt><dd><p>The type of message. One of <a class="reference internal" href="#vsmessagetype">VSMessageType</a>.</p>
<p>If <em>msgType</em> is mtFatal, VapourSynth will call abort() after
delivering the message.</p>
</dd>
<dt><em>msg</em></dt><dd><p>The message.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="addloghandler">VSLogHandle *addLogHandler(VSLogHandler handler, VSLogHandlerFree free, void *userData, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Installs a custom handler for the various error messages VapourSynth
emits. The message handler is per <a class="reference internal" href="#vscore">VSCore</a> instance. Returns a unique handle.</p>
<p>If no log handler is installed up to a few hundred messages are cached and
will be delivered as soon as a log handler is attached. This behavior exists
mostly so that warnings when auto-loading plugins (default behavior) won’t disappear-</p>
<dl>
<dt><em>handler</em></dt><dd><p>typedef void (VS_CC *VSLogHandler)(int msgType, const char *msg, void *userdata)</p>
<p>Custom message handler. If this is NULL, the default message
handler will be restored.</p>
<dl>
<dt><em>msgType</em></dt><dd><p>The type of message. One of <a class="reference internal" href="#vsmessagetype">VSMessageType</a>.</p>
<p>If <em>msgType</em> is mtFatal, VapourSynth will call abort() after the
message handler returns.</p>
</dd>
<dt><em>msg</em></dt><dd><p>The message.</p>
</dd>
</dl>
</dd>
<dt><em>free</em></dt><dd><p>typedef void (VS_CC *VSLogHandlerFree)(void *userData)</p>
<p>Called when a handler is removed.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer that gets passed to the message handler.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="removeloghandler">int removeLogHandler(VSLogHandle *handle, VSCore *core)</p>
<blockquote>
<div><p>Removes a custom handler. Return non-zero on success and zero if
the handle is invalid.</p>
<dl class="simple">
<dt><em>handle</em></dt><dd><p>Handle obtained from <a class="reference internal" href="#addloghandler">addLogHandler</a>().</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newvideoframe"><a class="reference internal" href="#vsframe">VSFrame</a> *newVideoFrame(const <a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> *format, int width, int height, const <a class="reference internal" href="#vsframe">VSFrame</a> *propSrc, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new video frame, optionally copying the properties attached to another
frame. It is a fatal error to pass invalid arguments to this function.</p>
<p>The new frame contains uninitialised memory.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired colorspace format. Must not be NULL.</p>
</dd>
</dl>
<p><em>width</em></p>
<dl class="simple">
<dt><em>height</em></dt><dd><p>The desired dimensions of the frame, in pixels. Must be greater than 0 and have a suitable multiple for the subsampling in format.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>See also <a class="reference internal" href="#newvideoframe2">newVideoFrame2</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newvideoframe2"><a class="reference internal" href="#vsframe">VSFrame</a> *newVideoFrame2(const <a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> *format, int width, int height, const <a class="reference internal" href="#vsframe">VSFrame</a> **planeSrc, const int *planes, const <a class="reference internal" href="#vsframe">VSFrame</a> *propSrc, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new video frame from the planes of existing frames, optionally copying
the properties attached to another frame. It is a fatal error to pass invalid arguments to this function.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired colorspace format. Must not be NULL.</p>
</dd>
</dl>
<p><em>width</em></p>
<dl class="simple">
<dt><em>height</em></dt><dd><p>The desired dimensions of the frame, in pixels. Must be greater than 0 and have a suitable multiple for the subsampling in format.</p>
</dd>
<dt><em>planeSrc</em></dt><dd><p>Array of frames from which planes will be copied. If any elements of
the array are NULL, the corresponding planes in the new frame will
contain uninitialised memory.</p>
</dd>
<dt><em>planes</em></dt><dd><p>Array of plane numbers indicating which plane to copy from the
corresponding source frame.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>Example (assume <em>frameA</em>, <em>frameB</em>, <em>frameC</em> are existing frames):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">VSFrame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">frames</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">frameA</span><span class="p">,</span><span class="w"> </span><span class="n">frameB</span><span class="p">,</span><span class="w"> </span><span class="n">frameC</span><span class="w"> </span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">planes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>
<span class="n">VSFrame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">newFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vsapi</span><span class="o">-&gt;</span><span class="n">newVideoFrame2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">frames</span><span class="p">,</span><span class="w"> </span><span class="n">planes</span><span class="p">,</span><span class="w"> </span><span class="n">frameB</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">);</span>
</pre></div>
</div>
<p>The newFrame’s first plane is now a copy of <em>frameA</em>’s second plane,
the second plane is a copy of <em>frameB</em>’s first plane,
the third plane is a copy of <em>frameC</em>’s third plane
and the properties have been copied from <em>frameB</em>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newaudioframe"><a class="reference internal" href="#vsframe">VSFrame</a> *newAudioFrame(const VSAudioFormat *format, int numSamples, const VSFrame *propSrc, VSCore *core)</p>
<blockquote>
<div><p>Creates a new audio frame, optionally copying the properties attached to another
frame. It is a fatal error to pass invalid arguments to this function.</p>
<p>The new frame contains uninitialised memory.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired audio format. Must not be NULL.</p>
</dd>
<dt><em>numSamples</em></dt><dd><p>The number of samples in the frame. All audio frames apart from the last one returned by a filter must have <a class="reference internal" href="#vs-audio-frame-samples">VS_AUDIO_FRAME_SAMPLES</a>.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>See also <a class="reference internal" href="#newaudioframe2">newAudioFrame2</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newaudioframe2"><a class="reference internal" href="#vsframe">VSFrame</a> *newAudioFrame2(const <a class="reference internal" href="#vsaudioformat">VSAudioFormat</a> *format, int numSamples, const <a class="reference internal" href="#vsframe">VSFrame</a> **channelSrc, const int *channels, const <a class="reference internal" href="#vsframe">VSFrame</a> *propSrc, VSCore *core)</p>
<blockquote>
<div><p>Creates a new audio frame, optionally copying the properties attached to another
frame. It is a fatal error to pass invalid arguments to this function.</p>
<p>The new frame contains uninitialised memory.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired audio format. Must not be NULL.</p>
</dd>
<dt><em>numSamples</em></dt><dd><p>The number of samples in the frame. All audio frames apart from the last one returned by a filter must have <a class="reference internal" href="#vs-audio-frame-samples">VS_AUDIO_FRAME_SAMPLES</a>.</p>
</dd>
<dt><em>channelSrc</em></dt><dd><p>Array of frames from which channels will be copied. If any elements of
the array are NULL, the corresponding planes in the new frame will
contain uninitialised memory.</p>
</dd>
<dt><em>channels</em></dt><dd><p>Array of channel numbers indicating which channel to copy from the
corresponding source frame. Note that the number refers to the nth channel
and not a channel name constant.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>See also <a class="reference internal" href="#newvideoframe2">newVideoFrame2</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freeframe">void freeFrame(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Decrements the reference count of a frame and deletes it when it reaches 0.</p>
<p>It is safe to pass NULL.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="addframeref">const <a class="reference internal" href="#vsframe">VSFrame</a> *addFrameRef(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Increments the reference count of a frame. Returns <em>f</em> as a convenience.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="copyframe"><a class="reference internal" href="#vsframe">VSFrame</a> *copyFrame(const <a class="reference internal" href="#vsframe">VSFrame</a> *f, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Duplicates the frame (not just the reference). As the frame buffer is
shared in a copy-on-write fashion, the frame content is not really
duplicated until a write operation occurs. This is transparent for the user.</p>
<p>Returns a pointer to the new frame. Ownership is transferred to the caller.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframepropertiesro">const <a class="reference internal" href="#vsmap">VSMap</a> *getFramePropertiesRO(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Returns a read-only pointer to a frame’s properties. The pointer is valid
as long as the frame lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframepropertiesrw"><a class="reference internal" href="#vsmap">VSMap</a> *getFramePropertiesRW(<a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Returns a read/write pointer to a frame’s properties. The pointer is valid
as long as the frame lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getstride">ptrdiff_t getStride(const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the distance in bytes between two consecutive lines of a plane of
a video frame. The stride is always positive. Returns 0 if the requested
<em>plane</em> doesn’t exist or if it isn’t a video frame.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getreadptr">const uint8_t *getReadPtr(const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int plane)</p>
<blockquote>
<div><p>Returns a read-only pointer to a <em>plane</em> or channel of a frame.
Returns NULL if an invalid <em>plane</em> or channel number is passed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t assume all three planes of a frame are allocated in one
contiguous chunk (they’re not).</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getwriteptr">uint8_t *getWritePtr(<a class="reference internal" href="#vsframe">VSFrame</a> *f, int plane)</p>
<blockquote>
<div><p>Returns a read-write pointer to a <em>plane</em> or channel of a frame.
Returns NULL if an invalid <em>plane</em> or channel number is passed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t assume all three planes of a frame are allocated in one
contiguous chunk (they’re not).</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getvideoframeformat">const <a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> *getVideoFrameFormat(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Retrieves the format of a video frame.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getaudioframeformat">const <a class="reference internal" href="#vsaudioformat">VSAudioFormat</a> *getAudioFrameFormat(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Retrieves the format of an audio frame.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframetype">int getFrameType(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Returns a value from <a class="reference internal" href="#vsmediatype">VSMediaType</a> to distinguish audio and video frames.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframewidth">int getFrameWidth(const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the width of a <em>plane</em> of a given video frame, in pixels. The width
depends on the plane number because of the possible chroma subsampling. Returns 0
for audio frames.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframeheight">int getFrameHeight(const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the height of a <em>plane</em> of a given video frame, in pixels. The height
depends on the plane number because of the possible chroma subsampling. Returns 0
for audio frames.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframelength">int getFrameLength(const <a class="reference internal" href="#vsframe">VSFrame</a> *f)</p>
<blockquote>
<div><p>Returns the number of audio samples in a frame. Always returns 1 for video frames.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createvideofilter">void createVideoFilter(<a class="reference internal" href="#vsmap">VSMap</a> *out, const char *name, const <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> *vi, <a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a> getFrame, <a class="reference internal" href="#vsfilterfree">VSFilterFree</a> free, int filterMode, const <a class="reference internal" href="#vsfilterdependency">VSFilterDependency</a> *dependencies, int numDeps, void *instanceData, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new video filter node.</p>
<dl class="simple">
<dt><em>out</em></dt><dd><p>Output map for the filter node.</p>
</dd>
<dt><em>name</em></dt><dd><p>Instance name. Please make it the same as the filter’s name for easy identification.</p>
</dd>
<dt><em>vi</em></dt><dd><p>The output format of the filter.</p>
</dd>
<dt><em>getFrame</em></dt><dd><p>The filter’s “getframe” function. Must not be NULL.</p>
</dd>
<dt><em>free</em></dt><dd><p>The filter’s “free” function. Can be NULL.</p>
</dd>
<dt><em>filterMode</em></dt><dd><p>One of <a class="reference internal" href="#vsfiltermode">VSFilterMode</a>. Indicates the level of parallelism
supported by the filter.</p>
</dd>
<dt><em>dependencies</em></dt><dd><p>An array of nodes the filter requests frames from and the access pattern.
Used to more efficiently configure caches.</p>
</dd>
<dt><em>numDeps</em></dt><dd><p>Length of the <em>dependencies</em> array.</p>
</dd>
<dt><em>instanceData</em></dt><dd><p>A pointer to the private filter data. This pointer will be passed to
the <em>getFrame</em> and <em>free</em> functions. It should be freed by
the <em>free</em> function.</p>
</dd>
</dl>
<p>After this function returns, <em>out</em> will contain the new node appended to the
“clip” property, or an error, if something went wrong.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createvideofilter2"><a class="reference internal" href="#vsnode">VSNode</a> *createVideoFilter2(const char *name, const <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> *vi, <a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a> getFrame, <a class="reference internal" href="#vsfilterfree">VSFilterFree</a> free, int filterMode, const <a class="reference internal" href="#vsfilterdependency">VSFilterDependency</a> *dependencies, int numDeps, void *instanceData, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Identical to <a class="reference internal" href="#createvideofilter">createVideoFilter</a> except that the new node is returned
instead of appended to the <em>out</em> map. Returns NULL on error.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createaudiofilter">void createAudioFilter(VSMap *out, const char *name, const VSAudioInfo *ai, VSFilterGetFrame getFrame, VSFilterFree free, int filterMode, const <a class="reference internal" href="#vsfilterdependency">VSFilterDependency</a> *dependencies, int numDeps, void *instanceData, VSCore *core)</p>
<blockquote>
<div><p>Creates a new video filter node.</p>
<dl class="simple">
<dt><em>out</em></dt><dd><p>Output map for the filter node.</p>
</dd>
<dt><em>name</em></dt><dd><p>Instance name. Please make it the same as the filter’s name for easy identification.</p>
</dd>
<dt><em>ai</em></dt><dd><p>The output format of the filter.</p>
</dd>
<dt><em>getFrame</em></dt><dd><p>The filter’s “getframe” function. Must not be NULL.</p>
</dd>
<dt><em>free</em></dt><dd><p>The filter’s “free” function. Can be NULL.</p>
</dd>
<dt><em>filterMode</em></dt><dd><p>One of <a class="reference internal" href="#vsfiltermode">VSFilterMode</a>. Indicates the level of parallelism
supported by the filter.</p>
</dd>
<dt><em>dependencies</em></dt><dd><p>An array of nodes the filter requests frames from and the access pattern.
Used to more efficiently configure caches.</p>
</dd>
<dt><em>numDeps</em></dt><dd><p>Length of the <em>dependencies</em> array.</p>
</dd>
<dt><em>instanceData</em></dt><dd><p>A pointer to the private filter data. This pointer will be passed to
the <em>getFrame</em> and <em>free</em> functions. It should be freed by
the <em>free</em> function.</p>
</dd>
</dl>
<p>After this function returns, <em>out</em> will contain the new node appended to the
“clip” property, or an error, if something went wrong.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createaudiofilter2">VSNode *createAudioFilter2(const char *name, const VSAudioInfo *ai, VSFilterGetFrame getFrame, VSFilterFree free, int filterMode, const <a class="reference internal" href="#vsfilterdependency">VSFilterDependency</a> *dependencies, int numDeps, void *instanceData, VSCore *core)</p>
<blockquote>
<div><p>Identical to <a class="reference internal" href="#createaudiofilter">createAudioFilter</a> except that the new node is returned
instead of appended to the <em>out</em> map. Returns NULL on error.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setlinearfilter">int setLinearFilter(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Must be called immediately after audio or video filter creation.
Returns the upper bound of how many additional frames it is
reasonable to pass to <a class="reference internal" href="#cacheframe">cacheFrame</a> when trying to make a request
more linear.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setcachemode">void setCacheMode(<a class="reference internal" href="#vsnode">VSNode</a> *node, int mode)</p>
<blockquote>
<div><p>Determines the strategy for frame caching. Pass a <a class="reference internal" href="#vscachemode">VSCacheMode</a> constant.
Mostly useful for cache debugging since the auto mode should work well
in just about all cases. Calls to this function may also be silently ignored.</p>
<p>Resets the cache to default options when called, discarding <a class="reference internal" href="#setcacheoptions">setCacheOptions</a>
changes.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setcacheoptions">void setCacheOptions(<a class="reference internal" href="#vsnode">VSNode</a> *node, int fixedSize, int maxSize, int maxHistorySize)</p>
<blockquote>
<div><p>Call after <a class="reference internal" href="#setcachemode">setCacheMode</a> or the changes will be discarded. Sets internal
details of a node’s associated cache. Calls to this function may also
be silently ignored.</p>
<dl class="simple">
<dt><em>fixedSize</em></dt><dd><p>Set to non-zero to make the cache always hold <em>maxSize</em> frames.</p>
</dd>
<dt><em>maxSize</em></dt><dd><p>The maximum number of frames to cache. Note that this value is automatically
adjusted using an internal algorithm unless <em>fixedSize</em> is set.</p>
</dd>
<dt><em>maxHistorySize</em></dt><dd><p>How many frames that have been recently evicted from the cache to keep track off.
Used to determine if growing or shrinking the cache is beneficial. Has no effect
when <em>fixedSize</em> is set.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freenode">void freeNode(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Decreases the reference count of a node and destroys it once it reaches 0.</p>
<p>It is safe to pass NULL.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="addnoderef"><a class="reference internal" href="#vsnode">VSNode</a> *addNodeRef(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Increment the reference count of a node. Returns the same <em>node</em> for convenience.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getnodetype">int getNodeType(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Returns <a class="reference internal" href="#vsmediatype">VSMediaType</a>. Used to determine if a node is of audio or video type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getvideoinfo">const <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> *getVideoInfo(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Returns a pointer to the video info associated with a node. The pointer is
valid as long as the node lives. It is undefined behavior to pass a non-video
node.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getaudioinfo">const <a class="reference internal" href="#vsaudioinfo">VSAudioInfo</a> *getAudioInfo(<a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Returns a pointer to the audio info associated with a node. The pointer is
valid as long as the node lives. It is undefined behavior to pass a non-audio
node.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getvideoformatname">int getVideoFormatName(const VSVideoFormat *format, char *buffer)</p>
<blockquote>
<div><p>Tries to output a fairly human-readable name of a video format.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The input video format.</p>
</dd>
<dt><em>buffer</em></dt><dd><p>Destination buffer. At most 32 bytes including terminating NULL
will be written.</p>
</dd>
</dl>
<p>Returns non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getaudioformatname">int getAudioFormatName(const VSAudioFormat *format, char *buffer)</p>
<blockquote>
<div><p>Tries to output a fairly human-readable name of an audio format.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The input audio format.</p>
</dd>
<dt><em>buffer</em></dt><dd><p>Destination buffer. At most 32 bytes including terminating NULL
will be written.</p>
</dd>
</dl>
<p>Returns non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="queryvideoformat">int queryVideoFormat(<a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> *format, int colorFamily, int sampleType, int bitsPerSample, int subSamplingW, int subSamplingH, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Fills out a <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> struct based on the provided arguments. Validates the arguments before filling out <em>format</em>.</p>
<dl>
<dt><em>format</em></dt><dd><p>The struct to fill out.</p>
</dd>
<dt><em>colorFamily</em></dt><dd><p>One of <a class="reference internal" href="#vscolorfamily">VSColorFamily</a>.</p>
</dd>
<dt><em>sampleType</em></dt><dd><p>One of <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd>
<dt><em>bitsPerSample</em></dt><dd><p>Number of meaningful bits for a single component. The valid range is
8-32.</p>
<p>For floating point formats only 16 or 32 bits are allowed.</p>
</dd>
<dt><em>subSamplingW</em></dt><dd><p>log2 of the horizontal chroma subsampling. 0 == no subsampling. The valid range is 0-4.</p>
</dd>
<dt><em>subSamplingH</em></dt><dd><p>log2 of the vertical chroma subsampling. 0 == no subsampling. The valid range is 0-4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RGB formats are not allowed to be subsampled in VapourSynth.</p>
</div>
</dd>
</dl>
<p>Returns non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="queryaudioformat">int queryAudioFormat(<a class="reference internal" href="#vsaudioformat">VSAudioFormat</a> *format, int sampleType, int bitsPerSample, uint64_t channelLayout, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Fills out a <a class="reference internal" href="#vsaudioformat">VSAudioFormat</a> struct based on the provided arguments. Validates the arguments before filling out <em>format</em>.</p>
<dl>
<dt><em>format</em></dt><dd><p>The struct to fill out.</p>
</dd>
<dt><em>sampleType</em></dt><dd><p>One of <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd>
<dt><em>bitsPerSample</em></dt><dd><p>Number of meaningful bits for a single component. The valid range is
8-32.</p>
<p>For floating point formats only 32 bits are allowed.</p>
</dd>
<dt><em>channelLayout</em></dt><dd><p>A bitmask constructed from bitshifted constants in <a class="reference internal" href="#vsaudiochannels">VSAudioChannels</a>. For example stereo is expressed as (1 &lt;&lt; acFrontLeft) | (1 &lt;&lt; acFrontRight).</p>
</dd>
</dl>
<p>Returns non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="queryvideoformatid">uint32_t queryVideoFormatID(int colorFamily, int sampleType, int bitsPerSample, int subSamplingW, int subSamplingH, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Get the id associated with a video format. Similar to <a class="reference internal" href="#queryvideoformat">queryVideoFormat</a>() except that it returns a format id instead
of filling out a <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> struct.</p>
<dl>
<dt><em>colorFamily</em></dt><dd><p>One of <a class="reference internal" href="#vscolorfamily">VSColorFamily</a>.</p>
</dd>
<dt><em>sampleType</em></dt><dd><p>One of <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd>
<dt><em>bitsPerSample</em></dt><dd><p>Number of meaningful bits for a single component. The valid range is
8-32.</p>
<p>For floating point formats, only 16 or 32 bits are allowed.</p>
</dd>
<dt><em>subSamplingW</em></dt><dd><p>log2 of the horizontal chroma subsampling. 0 == no subsampling. The valid range is 0-4.</p>
</dd>
<dt><em>subSamplingH</em></dt><dd><p>log2 of the vertical chroma subsampling. 0 == no subsampling. The valid range is 0-4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RGB formats are not allowed to be subsampled in VapourSynth.</p>
</div>
</dd>
</dl>
<p>Returns a valid format id if the provided arguments are valid, on error
0 is returned.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getvideoformatbyid">int getVideoFormatByID(<a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> *format, uint32_t id, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Fills out the <a class="reference internal" href="#vsvideoformat">VSVideoFormat</a> struct passed to <em>format</em> based</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The struct to fill out.</p>
</dd>
<dt><em>id</em></dt><dd><p>The format identifier: one of <a class="reference internal" href="#vspresetvideoformat">VSPresetVideoFormat</a> or a value gotten from <a class="reference internal" href="#queryvideoformatid">queryVideoFormatID</a>.</p>
</dd>
</dl>
<p>Returns 0 on failure and non-zero on success.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createmap"><a class="reference internal" href="#vsmap">VSMap</a> *createMap(void)</p>
<blockquote>
<div><p>Creates a new property map. It must be deallocated later with
<a class="reference internal" href="#freemap">freeMap</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freemap">void freeMap(<a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Frees a map and all the objects it contains.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="clearmap">void clearMap(<a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Deletes all the keys and their associated values from the map, leaving it
empty.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgeterror">const char *mapGetError(const <a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Returns a pointer to the error message contained in the map,
or NULL if there is no error set. The pointer is valid until
the next modifying operation on the map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapseterror">void mapSetError(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *errorMessage)</p>
<blockquote>
<div><p>Adds an error message to a map. The map is cleared first. The error
message is copied. In this state the map may only be freed, cleared
or queried for the error message.</p>
<p>For errors encountered in a filter’s “getframe” function, use
<a class="reference internal" href="#setfiltererror">setFilterError</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapnumkeys">int mapNumKeys(const <a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Returns the number of keys contained in a property map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetkey">const char *mapGetKey(const <a class="reference internal" href="#vsmap">VSMap</a> *map, int index)</p>
<blockquote>
<div><p>Returns the nth key from a property map.</p>
<p>Passing an invalid <em>index</em> will cause a fatal error.</p>
<p>The pointer is valid as long as the key exists in the map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapdeletekey">int mapDeleteKey(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Removes the property with the given key. All values associated with the
key are lost.</p>
<p>Returns 0 if the key isn’t in the map. Otherwise it returns 1.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapnumelements">int mapNumElements(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Returns the number of elements associated with a key in a property map.
Returns -1 if there is no such key in the map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgettype">int mapGetType(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Returns a value from <a class="reference internal" href="#vspropertytype">VSPropertyType</a> representing type
of elements in the given key. If there is no such key in the
map, the returned value is ptUnset. Note that also empty
arrays created with <a class="reference internal" href="#mapsetempty">mapSetEmpty</a> are typed.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetempty">int mapSetEmpty(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int type)</p>
<blockquote>
<div><p>Creates an empty array of <em>type</em> in <em>key</em>. Returns non-zero
value on failure due to <em>key</em> already existing or having an
invalid name.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetint">int64_t mapGetInt(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves an integer from a specified <em>key</em> in a <em>map</em>.</p>
<p>Returns the number on success, or 0 in case of error.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#mapgeterror">mapGetError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#mapnumelements">mapNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsmappropertyerror">VSMapPropertyError</a>, peSuccess on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetintsaturated">int mapGetIntSaturated(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Works just like <a class="reference internal" href="#mapgetint">mapGetInt</a>() except that the value returned is also
converted to an integer using saturation.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetintarray">const int64_t *mapGetIntArray(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int *error)</p>
<blockquote>
<div><p>Retrieves an array of integers from a map. Use this function if there
are a lot of numbers associated with a key, because it is faster than
calling <a class="reference internal" href="#mapgetint">mapGetInt</a>() in a loop.</p>
<p>Returns a pointer to the first element of the array on success, or NULL
in case of error. Use <a class="reference internal" href="#mapnumelements">mapNumElements</a>() to know the total number of
elements associated with a key.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetint">int mapSetInt(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int64_t i, int append)</p>
<blockquote>
<div><p>Sets an integer to the specified key in a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and underscore
may be used.</p>
</dd>
<dt><em>i</em></dt><dd><p>Value to store.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vsmapappendmode">VSMapAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type to an existing key.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetintarray">int mapSetIntArray(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const int64_t *i, int size)</p>
<blockquote>
<div><p>Adds an array of integers to a map. Use this function if there are a
lot of numbers to add, because it is faster than calling <a class="reference internal" href="#mapsetint">mapSetInt</a>()
in a loop.</p>
<p>If <em>map</em> already contains a property with this <em>key</em>, that property will
be overwritten and all old values will be lost.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and underscore
may be used.</p>
</dd>
<dt><em>i</em></dt><dd><p>Pointer to the first element of the array to store.</p>
</dd>
<dt><em>size</em></dt><dd><p>Number of integers to read from the array. It can be 0, in which case
no integers are read from the array, and the property will be created
empty.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if <em>size</em> is negative.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetfloat">double mapGetFloat(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a floating point number from a map.</p>
<p>Returns the number on success, or 0 in case of error.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetfloatsaturated">float mapGetFloatSaturated(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Works just like <a class="reference internal" href="#mapgetfloat">mapGetFloat</a>() except that the value returned is also
converted to a float.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetfloatarray">const double *mapGetFloatArray(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int *error)</p>
<blockquote>
<div><p>Retrieves an array of floating point numbers from a map. Use this function if there
are a lot of numbers associated with a key, because it is faster than
calling <a class="reference internal" href="#mapgetfloat">mapGetFloat</a>() in a loop.</p>
<p>Returns a pointer to the first element of the array on success, or NULL
in case of error. Use <a class="reference internal" href="#mapnumelements">mapNumElements</a>() to know the total number of
elements associated with a key.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetfloat">int mapSetFloat(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, double d, int append)</p>
<blockquote>
<div><p>Sets a float to the specified key in a map.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetfloatarray">int mapSetFloatArray(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const double *d, int size)</p>
<blockquote>
<div><p>Adds an array of floating point numbers to a map. Use this function if
there are a lot of numbers to add, because it is faster than calling
<a class="reference internal" href="#mapsetfloat">mapSetFloat</a>() in a loop.</p>
<p>If <em>map</em> already contains a property with this <em>key</em>, that property will
be overwritten and all old values will be lost.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and underscore
may be used.</p>
</dd>
<dt><em>d</em></dt><dd><p>Pointer to the first element of the array to store.</p>
</dd>
<dt><em>size</em></dt><dd><p>Number of floating point numbers to read from the array. It can be 0,
in which case no numbers are read from the array, and the property
will be created empty.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if <em>size</em> is negative.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetdata">const char *mapGetData(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves arbitrary binary data from a map. Checking <a class="reference internal" href="#mapgetdatatypehint">mapGetDataTypeHint</a>()
may provide a hint about whether or not the data is human readable.</p>
<p>Returns a pointer to the data on success, or NULL in case of error.</p>
<p>The array returned is guaranteed to be NULL-terminated. The NULL
byte is not considered to be part of the array (<a class="reference internal" href="#mapgetdatasize">mapGetDataSize</a>
doesn’t count it).</p>
<p>The pointer is valid until the map is destroyed, or until the
corresponding key is removed from the map or altered.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetdatasize">int mapGetDataSize(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Returns the size in bytes of a property of type ptData (see
<a class="reference internal" href="#vspropertytype">VSPropertyType</a>), or 0 in case of error. The terminating NULL byte
added by <a class="reference internal" href="#mapsetdata">mapSetData</a>() is not counted.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetdatatypehint">int mapGetDataTypeHint(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Returns the size in bytes of a property of type ptData (see
<a class="reference internal" href="#vspropertytype">VSPropertyType</a>), or 0 in case of error. The terminating NULL byte
added by <a class="reference internal" href="#mapsetdata">mapSetData</a>() is not counted.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetdata">int mapSetData(VSMap *map, const char *key, const char *data, int size, int type, int append)</p>
<blockquote>
<div><p>Sets binary data to the specified key in a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl>
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>data</em></dt><dd><p>Value to store.</p>
<p>This function copies the data, so the pointer should be freed when
no longer needed. A terminating NULL is always added to the copied data
but not included in the total size to make string handling easier.</p>
</dd>
<dt><em>size</em></dt><dd><p>The number of bytes to copy. If this is negative, everything up to
the first NULL byte will be copied.</p>
</dd>
<dt><em>type</em></dt><dd><p>One of <a class="reference internal" href="#vsdatatypehint">VSDataTypeHint</a> to hint whether or not it is human readable data.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vsmapappendmode">VSMapAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetnode"><a class="reference internal" href="#vsnode">VSNode</a> *mapGetNode(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a node from a map.</p>
<p>Returns a pointer to the node on success, or NULL in case of error.</p>
<p>This function increases the node’s reference count, so <a class="reference internal" href="#freenode">freeNode</a>() must
be used when the node is no longer needed.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetnode">int mapSetNode(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, <a class="reference internal" href="#vsnode">VSNode</a> *node, int append)</p>
<blockquote>
<div><p>Sets a node to the specified key in a map.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapconsumenode">int mapConsumeNode(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, <a class="reference internal" href="#vsnode">VSNode</a> *node, int append)</p>
<blockquote>
<div><p>Sets a node to the specified key in a map and decreases the reference count.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetframe">const <a class="reference internal" href="#vsframe">VSFrame</a> *propGetFrame(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a frame from a map.</p>
<p>Returns a pointer to the frame on success, or NULL in case of error.</p>
<p>This function increases the frame’s reference count, so <a class="reference internal" href="#freeframe">freeFrame</a>() must
be used when the frame is no longer needed.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetframe">int mapSetFrame(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int append)</p>
<blockquote>
<div><p>Sets a frame to the specified key in a map.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapconsumeframe">int mapConsumeFrame(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int append)</p>
<blockquote>
<div><p>Sets a frame to the specified key in a map and decreases the reference count.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapgetfunction">VSFunctionRef *mapGetFunc(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a function from a map.</p>
<p>Returns a pointer to the function on success, or NULL in case of error.</p>
<p>This function increases the function’s reference count, so <a class="reference internal" href="#freefunction">freeFunction</a>() must
be used when the function is no longer needed.</p>
<p>See <a class="reference internal" href="#mapgetint">mapGetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapsetfunction">int mapSetFunction(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, VSFunction *func, int append)</p>
<blockquote>
<div><p>Sets a function object to the specified key in a map.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="mapconsumefunction">int mapConsumeFunction(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, VSFunction *func, int append)</p>
<blockquote>
<div><p>Sets a function object to the specified key in a map and decreases the reference count.</p>
<p>See <a class="reference internal" href="#mapsetint">mapSetInt</a>() for a complete description of the arguments and general behavior.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginbyid"><a class="reference internal" href="#vsplugin">VSPlugin</a> *getPluginByID(const char *identifier, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a pointer to the plugin with the given identifier, or NULL
if not found.</p>
<dl class="simple">
<dt><em>identifier</em></dt><dd><p>Reverse URL that uniquely identifies the plugin.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginbynamespace"><a class="reference internal" href="#vsplugin">VSPlugin</a> *getPluginByNamespace(const char *ns, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a pointer to the plugin with the given namespace, or NULL
if not found.</p>
<p><a class="reference internal" href="#getpluginbyid">getPluginByID</a> is generally a better option.</p>
<dl class="simple">
<dt><em>ns</em></dt><dd><p>Namespace.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getnextplugin"><a class="reference internal" href="#vsplugin">VSPlugin</a> *getNextPlugin(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Used to enumerate over all currently loaded plugins. The order
is fixed but provides no other guarantees.</p>
<dl class="simple">
<dt><em>plugin</em></dt><dd><p>Current plugin. Pass NULL to get the first plugin.</p>
</dd>
</dl>
<p>Returns a pointer to the next plugin in order or NULL if the final
plugin has been reached.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginname">const char *getPluginName(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the name of the plugin that was passed to <a class="reference internal" href="#configplugin">configPlugin</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginid">const char *getPluginID(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the identifier of the plugin that was passed to <a class="reference internal" href="#configplugin">configPlugin</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginnamespace">const char *getPluginNamespace(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the namespace the plugin currently is loaded in.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getnextpluginfunction"><a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *getNextPluginFunction(<a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *func, VSPlugin *plugin)</p>
<blockquote>
<div><p>Used to enumerate over all functions in a plugin. The order
is fixed but provides no other guarantees.</p>
<dl class="simple">
<dt><em>func</em></dt><dd><p>Current function. Pass NULL to get the first function.</p>
</dd>
<dt><em>plugin</em></dt><dd><p>The plugin to enumerate functions in.</p>
</dd>
</dl>
<p>Returns a pointer to the next function in order or NULL if the final
function has been reached.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginfunctionbyname"><a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *getPluginFunctionByName(const char *name, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Get a function belonging to a plugin by its name.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginfunctionname">const char *getPluginFunctionName(<a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *func)</p>
<blockquote>
<div><p>Returns the name of the function that was passed to <a class="reference internal" href="#registerfunction">registerFunction</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginfunctionarguments">const char *getPluginFunctionArguments(<a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *func)</p>
<blockquote>
<div><p>Returns the argument string of the function that was passed to <a class="reference internal" href="#registerfunction">registerFunction</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginfunctionreturntype">const char *getPluginFunctionReturnType(<a class="reference internal" href="#vspluginfunction">VSPluginFunction</a> *func)</p>
<blockquote>
<div><p>Returns the return type string of the function that was passed to <a class="reference internal" href="#registerfunction">registerFunction</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginpath">const char *getPluginPath(const <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the absolute path to the plugin, including the plugin’s file
name. This is the real location of the plugin, i.e. there are no
symbolic links in the path.</p>
<p>Path elements are always delimited with forward slashes.</p>
<p>VapourSynth retains ownership of the returned pointer.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginversion">int getPluginVersion(const <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the version of the plugin. This is the same as the version number passed to <a class="reference internal" href="#configplugin">configPlugin</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="invoke"><a class="reference internal" href="#vsmap">VSMap</a> *invoke(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin, const char *name, const <a class="reference internal" href="#vsmap">VSMap</a> *args)</p>
<blockquote>
<div><p>Invokes a filter.</p>
<p>invoke() checks that
the <em>args</em> passed to the filter are consistent with the argument list
registered by the plugin that contains the filter, calls the filter’s
“create” function, and checks that the filter returns the declared types.
If everything goes smoothly, the filter will be ready to generate
frames after invoke() returns.</p>
<dl>
<dt><em>plugin</em></dt><dd><p>A pointer to the plugin where the filter is located. Must not be NULL.</p>
<p>See <a class="reference internal" href="#getpluginbyid">getPluginByID</a>().</p>
</dd>
<dt><em>name</em></dt><dd><p>Name of the filter to invoke.</p>
</dd>
<dt><em>args</em></dt><dd><p>Arguments for the filter.</p>
</dd>
</dl>
<p>Returns a map containing the filter’s return value(s). The caller takes
ownership of the map. Use <a class="reference internal" href="#mapgeterror">mapGetError</a>() to check if the filter was invoked
successfully.</p>
<p>Most filters will either set an error, or one or more clips
with the key “clip”. The exception to this are functions, for example
LoadPlugin, which doesn’t return any clips for obvious reasons.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createfunction"><a class="reference internal" href="#vsfunction">VSFunction</a> *createFunction(VSPublicFunction func, void *userData, VSFreeFunctionData free, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><dl>
<dt><em>func</em></dt><dd><p>typedef void (VS_CC *VSPublicFunction)(const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, void *userData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<p>User-defined function that may be called in any context.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer passed to <em>func</em>.</p>
</dd>
<dt><em>free</em></dt><dd><p>typedef void (VS_CC *VSFreeFunctionData)(void *userData)</p>
<p>Callback tasked with freeing <em>userData</em>. Can be NULL.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freefunction">void freeFunction(<a class="reference internal" href="#vsfunction">VSFunction</a> *f)</p>
<blockquote>
<div><p>Decrements the reference count of a function and deletes it when it reaches 0.</p>
<p>It is safe to pass NULL.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="addfunctionref"><a class="reference internal" href="#vsfunction">VSFunction</a> *addFunctionRef(<a class="reference internal" href="#vsfunction">VSFunction</a> *f)</p>
<blockquote>
<div><p>Increments the reference count of a function. Returns <em>f</em> as a convenience.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="callfunction">void callFunction(<a class="reference internal" href="#vsfunction">VSFunction</a> *func, const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out)</p>
<blockquote>
<div><p>Calls a function. If the call fails <em>out</em> will have an error set.</p>
<dl class="simple">
<dt><em>func</em></dt><dd><p>Function to be called.</p>
</dd>
<dt><em>in</em></dt><dd><p>Arguments passed to <em>func</em>.</p>
</dd>
<dt><em>out</em></dt><dd><p>Returned values from <em>func</em>.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframe">const <a class="reference internal" href="#vsframe">VSFrame</a> *getFrame(int n, <a class="reference internal" href="#vsnode">VSNode</a> *node, char *errorMsg, int bufSize)</p>
<blockquote>
<div><p>Fetches a frame synchronously. The frame is available when the function
returns.</p>
<p>This function is meant for external applications using the core as a
library, or if frame requests are necessary during a filter’s
initialization.</p>
<p>Thread-safe.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>errorMsg</em></dt><dd><p>Pointer to a buffer of <em>bufSize</em> bytes to store a possible error
message. Can be NULL if no error message is wanted.</p>
</dd>
<dt><em>bufSize</em></dt><dd><p>Maximum length for the error message, in bytes (including the
trailing ‘0’). Can be 0 if no error message is wanted.</p>
</dd>
</dl>
<p>Returns a reference to the generated frame, or NULL in case of failure.
The ownership of the frame is transferred to the caller.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never use inside a filter’s “getframe” function.</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframeasync">void getFrameAsync(int n, <a class="reference internal" href="#vsnode">VSNode</a> *node, VSFrameDoneCallback callback, void *userData)</p>
<blockquote>
<div><p>Requests the generation of a frame. When the frame is ready,
a user-provided function is called. Note that the completion
<em>callback</em> will only be called from a single thread at a time.</p>
<p>This function is meant for applications using VapourSynth as a library.</p>
<p>Thread-safe.</p>
<dl>
<dt><em>n</em></dt><dd><p>Frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>callback</em></dt><dd><p>typedef void (VS_CC *VSFrameDoneCallback)(void *userData, const <a class="reference internal" href="#vsframe">VSFrame</a> *f, int n, <a class="reference internal" href="#vsnode">VSNode</a> *node, const char *errorMsg)</p>
<p>Function of the client application called by the core when a requested
frame is ready, after a call to getFrameAsync().</p>
<p>If multiple frames were requested, they can be returned in any order.
Client applications must take care of reordering them.</p>
<p>This function is only ever called from one thread at a time.</p>
<p>getFrameAsync() may be called from this function to request more
frames.</p>
<dl class="simple">
<dt><em>userData</em></dt><dd><p>Pointer to private data from the client application, as passed
previously to getFrameAsync().</p>
</dd>
<dt><em>f</em></dt><dd><p>Contains a reference to the generated frame, or NULL in case of failure.
The ownership of the frame is transferred to the caller.</p>
</dd>
<dt><em>n</em></dt><dd><p>The frame number.</p>
</dd>
<dt><em>node</em></dt><dd><p>Node the frame belongs to.</p>
</dd>
<dt><em>errorMsg</em></dt><dd><p>String that usually contains an error message if the frame
generation failed. NULL if there is no error.</p>
</dd>
</dl>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer passed to the callback.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never use inside a filter’s “getframe” function.</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframefilter">const <a class="reference internal" href="#vsframe">VSFrame</a> *getFrameFilter(int n, <a class="reference internal" href="#vsnode">VSNode</a> *node, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Retrieves a frame that was previously requested with
<a class="reference internal" href="#requestframefilter">requestFrameFilter</a>().</p>
<p>Only use inside a filter’s “getframe” function.</p>
<p>A filter usually calls this function when its activation reason is
arAllFramesReady or arFrameReady. See <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>It is safe to retrieve a frame more than once, but each reference
needs to be freed.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is retrieved.</p>
</dd>
<dt><em>frameCtx</em></dt><dd><p>The context passed to the filter’s “getframe” function.</p>
</dd>
</dl>
<p>Returns a pointer to the requested frame, or NULL if the requested frame
is not available for any reason. The ownership of the frame is
transferred to the caller.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="requestframefilter">void requestFrameFilter(int n, <a class="reference internal" href="#vsnode">VSNode</a> *node, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Requests a frame from a node and returns immediately.</p>
<p>Only use inside a filter’s “getframe” function.</p>
<p>A filter usually calls this function when its activation reason is
arInitial. The requested frame can then be retrieved using
<a class="reference internal" href="#getframefilter">getFrameFilter</a>(), when the filter’s activation reason is
arAllFramesReady. See <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>It is best to request frames in ascending order, i.e. n, n+1, n+2, etc.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>frameCtx</em></dt><dd><p>The context passed to the filter’s “getframe” function.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="releaseframeearly">void releaseFrameEarly(<a class="reference internal" href="#vsnode">VSNode</a> *node, int n, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>By default all requested frames are referenced until a filter’s frame
request is done. In extreme cases where a filter needs to reduce 20+
frames into a single output frame it may be beneficial to request
these in batches and incrementally process the data instead.</p>
<p>Should rarely be needed.</p>
<p>Only use inside a filter’s “getframe” function.</p>
<dl class="simple">
<dt><em>node</em></dt><dd><p>The node from which the frame was requested.</p>
</dd>
<dt><em>n</em></dt><dd><p>The frame number. Invalid frame numbers (not cached or negative) will simply be ignored.</p>
</dd>
<dt><em>frameCtx</em></dt><dd><p>The context passed to the filter’s “getframe” function.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="registerfunction">int registerFunction(const char *name, const char *args, const char *returnType, VSPublicFunction argsFunc, void *functionData, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Function that registers a filter exported by the plugin. A plugin can
export any number of filters. This function may only be called during the plugin
loading phase unless the pcModifiable flag was set by <a class="reference internal" href="#configplugin">configPlugin</a>.</p>
<dl>
<dt><em>name</em></dt><dd><p>Filter name. The characters allowed are letters, numbers, and the
underscore. The first character must be a letter. In other words:
<code class="docutils literal notranslate"><span class="pre">^[a-zA-Z][a-zA-Z0-9_]*$</span></code></p>
<p>Filter names <em>should be</em> PascalCase.</p>
</dd>
<dt><em>args</em></dt><dd><p>String containing the filter’s list of arguments.</p>
<p>Arguments are separated by a semicolon. Each argument is made of
several fields separated by a colon. Don’t insert additional
whitespace characters, or VapourSynth will die.</p>
<dl>
<dt>Fields:</dt><dd><dl>
<dt>The argument name.</dt><dd><p>The same characters are allowed as for the filter’s name.
Argument names <em>should be</em> all lowercase and use only letters
and the underscore.</p>
</dd>
<dt>The type.</dt><dd><p>“int”: int64_t</p>
<p>“float”: double</p>
<p>“data”: const char*</p>
<p>“anode”: const <a class="reference internal" href="#vsnode">VSNode</a>* (audio type)</p>
<p>“vnode”: const <a class="reference internal" href="#vsnode">VSNode</a>* (video type)</p>
<p>“aframe”: const <a class="reference internal" href="#vsframe">VSFrame</a>* (audio type)</p>
<p>“vframe”: const <a class="reference internal" href="#vsframe">VSFrame</a>* (video type)</p>
<p>“func”: const VSFunctionRef*</p>
<p>It is possible to declare an array by appending “[]” to the type.</p>
</dd>
<dt>“opt”</dt><dd><p>If the parameter is optional.</p>
</dd>
<dt>“empty”</dt><dd><p>For arrays that are allowed to be empty.</p>
</dd>
<dt>“any”</dt><dd><p>Can only be placed last without a semicolon after. Indicates that all remaining arguments that don’t match
should also be passed through.</p>
</dd>
</dl>
</dd>
</dl>
<p>The following example declares the arguments “blah”, “moo”, and “asdf”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blah</span><span class="p">:</span><span class="n">vnode</span><span class="p">;</span><span class="n">moo</span><span class="p">:</span><span class="nb">int</span><span class="p">[]:</span><span class="n">opt</span><span class="p">;</span><span class="n">asdf</span><span class="p">:</span><span class="nb">float</span><span class="p">:</span><span class="n">opt</span><span class="p">;</span>
</pre></div>
</div>
<p>The following example declares the arguments “blah” and accepts all other arguments no matter the type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blah</span><span class="p">:</span><span class="n">vnode</span><span class="p">;</span><span class="nb">any</span>
</pre></div>
</div>
</dd>
<dt><em>returnType</em></dt><dd><p>Specifies works similarly to <em>args</em> but instead specifies which keys and what type will be returned. Typically this will be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clip</span><span class="p">:</span><span class="n">vnode</span><span class="p">;</span>
</pre></div>
</div>
<p>for video filters. It is important to not simply specify “any” for all filters since this information is used for better
auto-completion in many editors.</p>
</dd>
<dt><em>argsFunc</em></dt><dd><p>typedef void (VS_CC *VSPublicFunction)(const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, void *userData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<p>User-defined function called by the core to create an instance of the
filter. This function is often named <code class="docutils literal notranslate"><span class="pre">fooCreate</span></code>.</p>
<p>In this function, the filter’s input parameters should be retrieved
and validated, the filter’s private instance data should be
initialised, and <a class="reference internal" href="#createaudiofilter">createAudioFilter</a>() or <a class="reference internal" href="#createvideofilter">createVideoFilter</a>() should be called. This is where
the filter should perform any other initialisation it requires.</p>
<p>If for some reason you cannot create the filter, you have to free any
created node references using <a class="reference internal" href="#freenode">freeNode</a>(), call <a class="reference internal" href="#mapseterror">mapSetError</a>() on
<em>out</em>, and return.</p>
<dl>
<dt><em>in</em></dt><dd><p>Input parameter list.</p>
<p>Use <a class="reference internal" href="#mapgetint">mapGetInt</a>() and friends to retrieve a parameter value.</p>
<p>The map is guaranteed to exist only until the filter’s “init”
function returns. In other words, pointers returned by
<a class="reference internal" href="#mapgetdata">mapGetData</a>() will not be usable in the filter’s “getframe” and
“free” functions.</p>
</dd>
<dt><em>out</em></dt><dd><p>Output parameter list. <a class="reference internal" href="#createaudiofilter">createAudioFilter</a>() or <a class="reference internal" href="#createvideofilter">createVideoFilter</a>() will add the output
node(s) with the key named “clip”, or an error, if something went
wrong.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer that was passed to <a class="reference internal" href="#registerfunction">registerFunction</a>().</p>
</dd>
</dl>
</dd>
<dt><em>functionData</em></dt><dd><p>Pointer to user data that gets passed to <em>argsFunc</em> when creating a
filter. Useful to register multiple filters using a single <em>argsFunc</em>
function.</p>
</dd>
<dt><em>plugin</em></dt><dd><p>Pointer to the plugin object in the core, as passed to
VapourSynthPluginInit2().</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="cacheframe">void cacheFrame(const <a class="reference internal" href="#vsframe">VSFrame</a> *frame, int n, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Pushes a not requested frame into the cache. This is useful for (source) filters that greatly
benefit from completely linear access and producing all output in linear order.</p>
<p>This function may only be used in filters that were created with <a class="reference internal" href="#setlinearfilter">setLinearFilter</a>.</p>
<p>Only use inside a filter’s “getframe” function.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setfiltererror">void setFilterError(const char *errorMessage, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Adds an error message to a frame context, replacing the existing message,
if any.</p>
<p>This is the way to report errors in a filter’s “getframe” function.
Such errors are not necessarily fatal, i.e. the caller can try to
request the same frame again.</p>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<p id="getvapoursynthapi">const <a class="reference internal" href="#vsapi">VSAPI</a>* getVapourSynthAPI(int version)</p>
<blockquote>
<div><p>Returns a pointer to the global VSAPI instance.</p>
<p>Returns NULL if the requested API version is not supported or if the system
does not meet the minimum requirements to run VapourSynth. It is recommended
to pass <a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a>.</p>
</div></blockquote>
</section>
<section id="writing-plugins">
<h2>Writing plugins<a class="headerlink" href="#writing-plugins" title="Link to this heading"></a></h2>
<p>A simple VapourSynth plugin which exports one filter will contain five
functions: an entry point (called <code class="docutils literal notranslate"><span class="pre">VapourSynthPluginInit2</span></code>), a function tasked
with creating a filter instance (often called <code class="docutils literal notranslate"><span class="pre">fooCreate</span></code>), an “init” function
(often called <code class="docutils literal notranslate"><span class="pre">fooInit</span></code>), a “getframe” function (often called <code class="docutils literal notranslate"><span class="pre">fooGetframe</span></code>),
and a “free” function (often called <code class="docutils literal notranslate"><span class="pre">fooFree</span></code>). These functions are described
below.</p>
<p>Another thing a filter requires is an object for storing a filter instance’s
private data. This object will usually contain the filter’s input nodes (if it
has any) and a <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> struct describing the video the filter wants to
return.</p>
<p>The <a class="reference external" href="https://github.com/vapoursynth/vapoursynth/tree/master/sdk">sdk</a> folder
in the VapourSynth source contains some examples.</p>
<hr class="docutils" />
<p id="vsinitplugin">typedef void (VS_CC *VSInitPlugin)(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin, const <a class="reference internal" href="#vspluginapi">VSPLUGINAPI</a> *vspapi)</p>
<blockquote>
<div><p>A plugin’s entry point. It must be called <code class="docutils literal notranslate"><span class="pre">VapourSynthPluginInit2</span></code>.
This function is called after the core loads the shared library. Its purpose
is to configure the plugin and to register the filters the plugin wants to
export.</p>
<dl class="simple">
<dt><em>plugin</em></dt><dd><p>A pointer to the plugin object to be initialized.</p>
</dd>
<dt><em>vspapi</em></dt><dd><p>A pointer to a <a class="reference internal" href="#vspluginapi">VSPLUGINAPI</a> struct with a subset of the VapourSynth API used for initializing plugins.
The proper way to do things is to call <a class="reference internal" href="#configplugin">configPlugin</a> and then <a class="reference internal" href="#registerfunction">registerFunction</a> for each function to export.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="vsfiltergetframe">typedef const <a class="reference internal" href="#vsframe">VSFrame</a> *(VS_CC *VSFilterGetFrame)(int n, int activationReason, void *instanceData, void **frameData, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>A filter’s “getframe” function. It is called by the core when it needs
the filter to generate a frame.</p>
<p>It is possible to allocate local data, persistent during the multiple
calls requesting the output frame.</p>
<p>In case of error, call <a class="reference internal" href="#setfiltererror">setFilterError</a>(), free *frameData if required,
and return NULL.</p>
<p>Depending on the <a class="reference internal" href="#vsfiltermode">VSFilterMode</a> set for the filter, multiple output frames
could be requested concurrently.</p>
<p>It is never called concurrently for the same frame number.</p>
<dl>
<dt><em>n</em></dt><dd><p>Requested frame number.</p>
</dd>
<dt><em>activationReason</em></dt><dd><p>One of <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>This function is first called with <em>activationReason</em> arInitial. At this
point the function should request the input frames it needs and return
NULL. When one or all of the requested frames are ready, this function
is called again with arAllFramesReady.
The function should only return a frame when called with
<em>activationReason</em> arAllFramesReady.</p>
<p>If a the function is called with arError all processing has to be aborted
and any.</p>
</dd>
<dt><em>instanceData</em></dt><dd><p>The filter’s private instance data.</p>
</dd>
<dt><em>frameData</em></dt><dd><p>Optional private data associated with output frame number <em>n</em>.
It must be deallocated before the last call for the given frame
(arAllFramesReady or error).</p>
<p>It points to a void *[4] array of memory that may be used freely.
See filters like Splice and Trim for examples.</p>
</dd>
</dl>
<p>Return a reference to the output frame number <em>n</em> when it is ready, or NULL.
The ownership of the frame is transferred to the caller.</p>
</div></blockquote>
<hr class="docutils" />
<p id="vsfilterfree">typedef void (VS_CC *VSFilterFree)(void *instanceData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>A filter’s “free” function.</p>
<p>This is where the filter should free everything it allocated,
including its instance data.</p>
<dl class="simple">
<dt><em>instanceData</em></dt><dd><p>The filter’s private instance data.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../apireference.html" class="btn btn-neutral float-left" title="VapourSynth C API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vshelper4.h.html" class="btn btn-neutral float-right" title="VSHelper4.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2012-2023, Fredrik Mellbin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>